#include "generator.hpp"
#include <iostream>
#include "../exceptions/contract.hpp"
#include "builder.hpp"
#include <boost/filesystem.hpp>
#include <boost/algorithm/string/case_conv.hpp>
#include <boost/algorithm/string/replace.hpp>
#include "../version.hpp"

using namespace std;
namespace bfs = boost::filesystem;
namespace alg = boost::algorithm;

namespace Vlinder { namespace Rubicon { namespace Compiler {
Generator::Generator(string const &output_directory_name, string const &namespace_prefix, string const &namespace_suffix)
	: output_directory_name_(output_directory_name)
	, namespace_prefix_(namespace_prefix)
	, namespace_suffix_(namespace_suffix)
{ /* no-op */ }
Generator::~Generator()
{ /* no-op */ }

Generator& Generator::operator()(Builder const &builder, bool output_dependencies)
{
	builder_ = &builder;
	setNamespaceName();
	createOutputDirectory();
	if (output_dependencies)
	{
		outputDependencies();
	}
	else
	{ /* don't output dependencies */ }
	outputTypes();
	return *this;
}

void Generator::setNamespaceName()
{
	invariant(builder_);
	namespace_name_ = namespace_prefix_ + builder_->getModuleName() + namespace_suffix_;
}
void Generator::createOutputDirectory()
{
	if (output_directory_name_.empty())
	{
		output_directory_name_ = alg::replace_all_copy(alg::to_lower_copy(getNamespaceName()), "::", "/");
		cout << "Using output directory " << output_directory_name_ << endl;
	}
	else
	{ /* already have a directory name */ }
	bfs::create_directories(output_directory_name_);
}
void Generator::outputDependencies() const
{
	invariant(builder_);
	{
		auto type_dependencies(builder_->getTypeDependencies());
		string type_dependencies_filename = (bfs::path(getOutputDirectoryName()) / "types.dot").string();
		ofstream type_dependencies_file(type_dependencies_filename, ofstream::trunc);
		type_dependencies_file << type_dependencies << endl;
	}
	{
		auto value_dependencies(builder_->getValueDependencies());
		string value_dependencies_filename = (bfs::path(getOutputDirectoryName()) / "values.dot").string();
		ofstream value_dependencies_file(value_dependencies_filename, ofstream::trunc);
		value_dependencies_file << value_dependencies << endl;
	}
}
void Generator::outputTypes()
{
	for (auto type_assignment : builder_->getTypeAssignments())
	{
		generateHeader(type_assignment);
		generateImplementation(type_assignment);
	}
}
void Generator::generateHeader(TypeAssignment const &type_assignment)
{
	bfs::path const directory(getOutputDirectoryName());
	bfs::path const filename(directory / (alg::to_lower_copy(type_assignment.getName()) + ".hpp"));
	ofstream ofs(filename.string(), ofstream::trunc);

	generatePreamble(ofs);
	openIncludeGuard(ofs, type_assignment);
	generateIncludeDirectives(ofs, type_assignment);
//	// output the re-include guards
//
//	string const namespace_declaration(
//		  string("namespace ")
//		+ alg::replace_all_copy(alg::to_lower_copy(listener_->getModuleNamespace()), "::", " { namespace ")
//		+ " {"
//		);
//	string const namespace_close(count(namespace_declaration.begin(), namespace_declaration.end(), '{'), '}');
//
//	ofs << "/* GENERATED CODE, DO NOT EDIT */\n";
//	ofs << namespace_declaration << "\n";
//	type_assignment.generateHeader(ofs);
//	ofs << namespace_close << "\n";
//
	closeIncludeGuard(ofs);
}
void Generator::generateImplementation(TypeAssignment const &type_assignment)
{
	bfs::path const directory(getOutputDirectoryName());
	bfs::path const filename(directory / (alg::to_lower_copy(type_assignment.getName()) + ".cpp"));
	ofstream ofs(filename.string(), ofstream::trunc);

	generatePreamble(ofs);

//	string const namespace_declaration(
//		  string("namespace ")
//		+ alg::replace_all_copy(alg::to_lower_copy(listener_->getModuleNamespace()), "::", " { namespace ")
//		+ " {"
//		);
//	string const namespace_close(count(namespace_declaration.begin(), namespace_declaration.end(), '{'), '}');
//
//	ofs << "/* GENERATED CODE, DO NOT EDIT */\n";
//	ofs << "#include \"" << alg::to_lower_copy(type_assignment.getName()) << ".hpp" << "\"\n";
//	ofs << "\n";
//	ofs << namespace_declaration << "\n";
//	type_assignment.generateImplementation(ofs);
//	ofs << namespace_close << "\n";
//
}
void Generator::generatePreamble(std::ostream &ofs)
{
	ofs <<
		"/*\n"
		" * Generated by Rubicon version " << DATECODE << "\n"
		" * This is the " << builder_->getModuleName() << " module\n"
		" * THIS IS GENERATED CODE - DO NOT MODIFY\n"
		" */\n"
		;
}
void Generator::openIncludeGuard(std::ostream &ofs, TypeAssignment const &type_assignment)
{
	string const guard(
		  string("generated_")
		+ alg::replace_all_copy(alg::to_lower_copy(getNamespaceName()), "::", "_")
		+ "_"
		+ alg::to_lower_copy(type_assignment.getName())
		+ "_hpp"
		);
	ofs << "#ifndef " << guard << "\n";
	ofs << "#define " << guard << "\n\n";
}
void Generator::closeIncludeGuard(std::ostream &ofs)
{
	ofs <<
		"\n"
		"#endif\n"
		;
}
void Generator::generateIncludeDirectives(std::ostream &ofs, TypeAssignment const &type_assignment)
{

}

}}}


